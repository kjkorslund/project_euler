package problems_pg2;

import utils.PolygonalMath;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

public class P61 {
    /**
     * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
     * and are generated by the following formulae:
     *
     * <pre>
     * Triangle         P_3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
     * Square           P_4,n=n2             1, 4, 9, 16, 25, ...
     * Pentagonal       P_5,n=n(3n−1)/2      1, 5, 12, 22, 35, ...
     * Hexagonal        P_6,n=n(2n−1)        1, 6, 15, 28, 45, ...
     * Heptagonal       P_7,n=n(5n−3)/2      1, 7, 18, 34, 55, ...
     * Octagonal        P_8,n=n(3n−2)        1, 8, 21, 40, 65, ...
     * </pre>
     *
     * <p>
     * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
     * <p>
     * The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
     * Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
     * This is the only set of 4-digit numbers with this property.
     * <p>
     * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
     */
    public static void main(String[] args) {

        HashMap<Integer, List<Long>> allPolygonalValuesByOrder = new HashMap<>();
        allPolygonalValuesByOrder.put(3, getPolygonalValues(PolygonalMath::triangle, 1000, 10000));
        allPolygonalValuesByOrder.put(4, getPolygonalValues(PolygonalMath::square, 1000, 10000));
        allPolygonalValuesByOrder.put(5, getPolygonalValues(PolygonalMath::pentagonal, 1000, 10000));
        allPolygonalValuesByOrder.put(6, getPolygonalValues(PolygonalMath::hexagonal, 1000, 10000));
        allPolygonalValuesByOrder.put(7, getPolygonalValues(PolygonalMath::heptagonal, 1000, 10000));
        allPolygonalValuesByOrder.put(8, getPolygonalValues(PolygonalMath::octagonal, 1000, 10000));

        // Initialize the candidate queue with the octagonal candidates
        LinkedList<Candidate> candidateQueue = new LinkedList<>();
        for(long polygonal : allPolygonalValuesByOrder.get(8)) {
            candidateQueue.addLast(new Candidate(Collections.singletonList(polygonal), List.of(7,6,5,4,3)));
        }

        // Process the queue until empty, printing any matches found along the way.  Progress is made by searching
        // for eligible candidates among the remaining unmatched orders, and creating new Candidate objects at the end
        // of the queue for any discovered pathways
        long iterationCount = 0;
        while(!candidateQueue.isEmpty()) {
            Candidate candidate = candidateQueue.removeFirst();
            iterationCount++;
            for(int order : candidate.remainingOrders) {
                for (long polygonalVal : allPolygonalValuesByOrder.get(order)) {
                    if (Candidate.isMatch(candidate.polygonalValues.peekLast(), polygonalVal)) {
                        Candidate newCandidate = makeNewCandidate(candidate, polygonalVal, order);
                        if (newCandidate.isCompleteMatch()) {
                            System.out.println("Match: " + newCandidate.polygonalValues);
                            System.out.println("Sum: " + newCandidate.polygonalValues.stream().reduce(0L, Long::sum));
                        } else if (!newCandidate.remainingOrders.isEmpty()){
                            candidateQueue.addLast(newCandidate);
                        }
                    }
                }
            }
        }
        System.out.println("Iteration count: " + iterationCount);
    }

    private static Candidate makeNewCandidate(Candidate source, long val, int order) {
        LinkedList<Long> newValues = new LinkedList<>(source.polygonalValues);
        newValues.addLast(val);
        List<Integer> newRemainingOrders = source.remainingOrders.stream()
                .filter(o -> o != order).collect(Collectors.toList());
        return new Candidate(newValues, newRemainingOrders);
    }

    private static List<Long> getPolygonalValues(Function<Long, Long> polygonalFn, long start, long end) {
        List<Long> results = new ArrayList<>();

        long l = 1L;
        long result = 0L;
        while (result < start) {
            result = polygonalFn.apply(l++);
        }

        while (result < end) {
            results.add(result);
            result = polygonalFn.apply(l++);
        }

        return results;
    }

    private static class Candidate {
        final LinkedList<Long> polygonalValues;
        final List<Integer> remainingOrders;

        public Candidate(List<Integer> remainingOrders) {
            this.polygonalValues = new LinkedList<>();
            this.remainingOrders = remainingOrders;
        }

        public Candidate(List<Long> polygonalValues, List<Integer> remainingOrders) {
            this.polygonalValues = new LinkedList<>(polygonalValues);
            this.remainingOrders = remainingOrders;
        }

        public boolean isCompleteMatch() {
            return remainingOrders.isEmpty() && isMatch(polygonalValues.getLast(), polygonalValues.getFirst());
        }

        public static boolean isMatch(long first, long second) {
            return first%100 == second/100;
        }
    }
}
