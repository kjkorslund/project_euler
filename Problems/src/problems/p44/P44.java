package problems.p44;

import java.util.Arrays;
import java.util.HashMap;

import utils.IntegerMath;
import utils.SearchUtils;
import utils.SearchUtils.Eval;
import utils.SearchUtils.NotFoundException;

public class P44 {
	/*
	 * Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2. The first
	 * ten pentagonal numbers are:
	 * 
	 * 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
	 * 
	 * It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their
	 * difference, 70 − 22 = 48, is not pentagonal.
	 * 
	 * Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
	 * difference is pentagonal and D = |Pk − Pj| is minimised; what is the
	 * value of D?
	 */
	public static void main(String[] args) {
		// New approach. I know the difference itself must be pentagonal, and
		// I am looking for the minimal difference. If I start with the
		// smallest possible pentagonal and iterate up, as long as I can analyze
		// each possible answer in a bounded fashion, I can trivially solve
		// this.
		//
		// The trick is putting an upper bound on computing the potential pairs
		// for the difference. But I think I can take advantage of the formula
		// for pentagonal numbers. Each successive pair of numbers is
		// increasingly distant from each other, and eventually successive pairs
		// will be so far apart that even the difference between successive
		// pairs will be larger than the target difference. We can stop at that
		// point.
		
//		long pLast = 0;
//		for(long n=1; n<10000000000L; n++) {
//			long p = pentagonal(n);
//			if (p < pLast) {
//				System.out.println(n);
//				System.out.println(p);
//				System.out.println(pLast);
//				break;
//			}
//		}
//		System.out.println("Done");
		
		int cap = 10000;
		System.out.println("Starting test");
		for(long n=1; n<cap; n++) {
			if (n%100 == 0) {
				System.out.println("Testing n=" + n + " (" + pentagonal(n) + ")");
			}
			Long result = testAnswer(n);
			if (result != null) {
				System.out.println("Match:  " + result);
				return;
			}
		}
		System.out.println("No match for n < " + cap);
		
//		long t = System.currentTimeMillis();
//		for(long n = 100000; n < 100010; n++) {
//			long p = pentagonal(n);
//			isPentagonal2(n);
//		}
//		t = System.currentTimeMillis() - t;
//		System.out.println("Time taken: " + t);
		
		
	}
	
	static Long testAnswer(long n) {
		long pd = pentagonal(n);
		
		long m = n+1;
		long p = pentagonal(m);
		long pLast = pd;
		while(p - pLast <= pd) {
//			System.out.println("Looking for pPair for " + p);
			Long pp = pPair(m,p,pd);
			if (pp != null && isPentagonal(p + pp)) {
				System.out.println("Match: " + Arrays.toString(new long[]{pd, p, pp, p + pp}));
				return pd;
			}
			
			pLast = p;
			p = pentagonal(++m);
		}
		return null;
	}

	// For pentagonal p (index n), find the pentagonal pair that produces
	// difference pd (if it exists)
	static Long pPair(long n, long p, long pd) {
		long pp = pentagonal(++n);
		while (pp - p < pd) {
			pp = pentagonal(++n);
		}
		return (pp - p == pd) ? pp : null;
//		long pair = p + pd;
//		return (isPentagonal(pair)) ? pair : null;
	}

	// This method is based on binary search. I figured out how to bound n based
	// on the formula. Unfortunately, this much slower than caching for
	// large n.
	static boolean isPentagonal2(final long p) {
		long rootP = IntegerMath.isqrt(p);
		long nMax = rootP+1;
		long nMin = rootP * 2 / 3;
		try {
			SearchUtils.binarySearch(nMin, nMax, new Eval<Long>() {
				@Override
				public int eval(Long n) {
					return Long.compare(p, pentagonal(n));
				}
			});
			return true;
		} catch (NotFoundException e) {
			return false;
		}
	}
	
	static boolean isPentagonal(long p) {
//		int i=1;
//		long p = pentagonal(i);
//		while(p < n) {
//			i++;
//			p = pentagonal(i);
//		}
//		return p == n;
		long t = System.currentTimeMillis();
		Long n = PentagonalCache.instance.reversePentagonal(p);
		t = System.currentTimeMillis() - t;
		if (t > 100) System.out.println("Pentagonal check for " + p + " took " + t + "ms");
		return (n != null);
	}
	
	static long pentagonal(long n) {
		// Predetermined that anything above this value will exceed MAX_LONG
		if (n < 1753413057) {
			return n*(3*n-1)/2;
		}
		throw new IndexOutOfBoundsException();
	}
	
	static class PentagonalCache {
		static PentagonalCache instance = new PentagonalCache();
		
		long maxN = 0;
		HashMap<Long,Long> p2n = new HashMap<Long,Long>();
		
		Long reversePentagonal(long p) {
			if (p2n.containsKey(p)) return p2n.get(p);
			populateThrough(p);
			return p2n.get(p);
		}
		
		void populateThrough(long p) {
			long n = maxN+1;
			long pn = pentagonal(n);
			while(pn <= p) {
				p2n.put(pn, n);
				n++;
				pn = pentagonal(n);
			}
			maxN = n-1;
		}
	}
}
