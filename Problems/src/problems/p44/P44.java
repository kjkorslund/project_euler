package problems.p44;

import java.util.Arrays;
import java.util.HashMap;

import utils.IntegerMath;
import utils.MathUtils;
import utils.Pair;
import utils.SearchUtils;
import utils.SearchUtils.Eval;
import utils.SearchUtils.NotFoundException;

public class P44 {
	/*
	 * Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2. The first
	 * ten pentagonal numbers are:
	 * 
	 * 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
	 * 
	 * It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their
	 * difference, 70 − 22 = 48, is not pentagonal.
	 * 
	 * Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
	 * difference is pentagonal and D = |Pk − Pj| is minimised; what is the
	 * value of D?
	 */
	public static void main(String[] args) {
		// New approach. I know the difference itself must be pentagonal, and
		// I am looking for the minimal difference. If I start with the
		// smallest possible pentagonal and iterate up, as long as I can analyze
		// each possible answer in a bounded fashion, I can trivially solve
		// this.
		//
		// The trick is putting an upper bound on computing the potential pairs
		// for the difference. But I think I can take advantage of the formula
		// for pentagonal numbers. Each successive pair of numbers is
		// increasingly distant from each other, and eventually successive pairs
		// will be so far apart that even the difference between successive
		// pairs will be larger than the target difference. We can stop at that
		// point.
		
		int cap = 10000;
		System.out.println("Starting test");
		for(long n=1; n<cap; n++) {
			if (n%100 == 0) {
				System.out.println("Testing n=" + n + " (" + pentagonal(n) + ")");
			}
			Pair<Long> result = checkAnswer(n);
			if (result != null) {
				System.out.println("Match:  " + n + " --> " + result);
				long p1 = pentagonal(result.first);
				long p2 = pentagonal(result.second);
				System.out.println("  " + (p2-p1)
						+ ", " + p1
						+ ", " + p2
						+ ", " + (p1+p2));
				return;
			}
		}
		System.out.println("No match for n < " + cap);
		
	}
	
	/**
	 * @param nTarget
	 * @return pair of (n,m) for which p(n) - p(m) = p(nTarget), and
	 *         isPentagonal(p(n) + p(m))...or null if no such pair exists.
	 */
	static Pair<Long> checkAnswer(long nTarget) {
		// The formula is always increasing (term?) - p(n+1) is always greater than p(n).
		// This means we can make the following assumptions:
		// - If p(n) - p(m) < pDiff, then p(n-1) - p(m) will also be less than pDiff, and
		//   p(n) - p(m+1) will also be < pDiff
		// - If p(n) - p(m) > pDiff, then [reverse of above]
		//
		// The algorithm below implements an efficient search algorithm for
		// pairs of numbers. It works by starting from some n and m, and always
		// incrementing either n or m depending on whether the different between
		// them is higher or lower than the target. Because of the pentagonal
		// formula, eventually the difference between p(n) and p(n+1) will
		// become greater than the target difference. At that point the
		// algorithm will increment n such that n==m. At that point, we know
		// that it is impossible for future values of n and m to produce a
		// result.
		//
		
		long pTarget = pentagonal(nTarget);
		
		long n = 1;
		long m = nTarget;
		while(m > n) {
			long pn = pentagonal(n);
			long pm = pentagonal(m);
			long pDiff = pm-pn;
			if (pDiff > pTarget) n++;
			else if (pDiff < pTarget) m++;
			else {
				long pSum = pn+pm;
				if (isPentagonal(pSum)) {
					return new Pair<Long>(n,m);
				}
				m++;
			}
		}
		return null;
	}

	// For pentagonal p (index n), find the pentagonal pair that produces
	// difference pd (if it exists)
	static Long pPair(long n, long p, long pd) {
		long pp = pentagonal(++n);
		while (pp - p < pd) {
			pp = pentagonal(++n);
		}
		return (pp - p == pd) ? pp : null;
//		long pair = p + pd;
//		return (isPentagonal(pair)) ? pair : null;
	}

	// This method is based on binary search. I figured out how to bound n based
	// on the formula. Unfortunately, this much slower than caching for
	// large n.
	static boolean isPentagonal2(final long p) {
		long rootP = IntegerMath.isqrt(p);
		long nMax = rootP+1;
		long nMin = rootP * 2 / 3;
		try {
			SearchUtils.binarySearch(nMin, nMax, new Eval<Long>() {
				@Override
				public int eval(Long n) {
					return Long.compare(p, pentagonal(n));
				}
			});
			return true;
		} catch (NotFoundException e) {
			return false;
		}
	}
	
	static boolean isPentagonal(long p) {
//		int i=1;
//		long p = pentagonal(i);
//		while(p < n) {
//			i++;
//			p = pentagonal(i);
//		}
//		return p == n;
		long t = System.currentTimeMillis();
		Long n = PentagonalCache.instance.reversePentagonal(p);
		t = System.currentTimeMillis() - t;
		if (t > 100) System.out.println("Pentagonal check for " + p + " took " + t + "ms");
		return (n != null);
	}
	
	static long pentagonal(long n) {
		// Predetermined that anything above this value will exceed MAX_LONG
		if (n < 1753413057) {
			return n*(3*n-1)/2;
		}
		throw new IndexOutOfBoundsException();
	}
	
	static class PentagonalCache {
		static PentagonalCache instance = new PentagonalCache();
		
		long maxN = 0;
		HashMap<Long,Long> p2n = new HashMap<Long,Long>();
		
		Long reversePentagonal(long p) {
			if (p2n.containsKey(p)) return p2n.get(p);
			populateThrough(p);
			return p2n.get(p);
		}
		
		void populateThrough(long p) {
			long n = maxN+1;
			long pn = pentagonal(n);
			while(pn <= p) {
				p2n.put(pn, n);
				n++;
				pn = pentagonal(n);
			}
			maxN = n-1;
		}
	}
}
