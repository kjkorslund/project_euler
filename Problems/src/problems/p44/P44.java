package problems.p44;

import java.util.Arrays;
import java.util.HashMap;

public class P44 {
	/*
	 * Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2. The first
	 * ten pentagonal numbers are:
	 * 
	 * 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
	 * 
	 * It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their
	 * difference, 70 − 22 = 48, is not pentagonal.
	 * 
	 * Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
	 * difference is pentagonal and D = |Pk − Pj| is minimised; what is the
	 * value of D?
	 */
	public static void main(String[] args) {
		// New approach. I know the difference itself must be pentagonal, and
		// I am looking for the minimal difference. If I start with the
		// smallest possible pentagonal and iterate up, as long as I can analyze
		// each possible answer in a bounded fashion, I can trivially solve
		// this.
		//
		// The trick is putting an upper bound on computing the potential pairs
		// for the difference. But I think I can take advantage of the formula
		// for pentagonal numbers. Each successive pair of numbers is
		// increasingly distant from each other, and eventually successive pairs
		// will be so far apart that even the difference between successive
		// pairs will be larger than the target difference. We can stop at that
		// point.
		
		int cap = 1000;
		System.out.println("Starting test");
		for(long n=1; n<cap; n++) {
			if (n%100 == 0) {
				System.out.println("Testing n=" + n + " (" + pentagonal(n) + ")");
			}
			Long result = testAnswer(n);
			if (result != null) {
				System.out.println("Match:  " + result);
				return;
			}
		}
		System.out.println("No match for n < " + cap);
	}
	
	static Long testAnswer(long n) {
		long pd = pentagonal(n);
		
		long m = n+1;
		long p = pentagonal(m);
		long pLast = pd;
		while(p - pLast <= pd) {
//			System.out.println("Looking for pPair for " + p);
			Long pp = pPair(m,p,pd);
			if (pp != null && isPentagonal(p + pp)) {
				System.out.println("Match: " + Arrays.toString(new long[]{pd, p, pp, p + pp}));
				return pd;
			}
			
			pLast = p;
			p = pentagonal(++m);
		}
		return null;
	}

	// For pentagonal p (index n), find the pentagonal pair that produces
	// difference pd (if it exists)
	static Long pPair(long n, long p, long pd) {
//		long pp = pentagonal(++n);
//		while (pp - p < pd) {
//			pp = pentagonal(++n);
//		}
//		return (pp - p == pd) ? pp : null;
		long pair = p + pd;
		return (isPentagonal(pair)) ? pair : null;
	}
	
	static boolean isPentagonal(long p) {
//		int i=1;
//		long p = pentagonal(i);
//		while(p < n) {
//			i++;
//			p = pentagonal(i);
//		}
//		return p == n;
		Long n = PentagonalCache.instance.reversePentagonal(p);
		return (n != null);
	}
	
	static long pentagonal(long n) {
		return n*(3*n-1)/2;
	}
	
	static class PentagonalCache {
		static PentagonalCache instance = new PentagonalCache();
		
		long maxN = 0;
		HashMap<Long,Long> p2n = new HashMap<Long,Long>();
		
		Long reversePentagonal(long p) {
			if (p2n.containsKey(p)) return p2n.get(p);
			populateThrough(p);
			return p2n.get(p);
		}
		
		void populateThrough(long p) {
			long n = maxN+1;
			long pn = pentagonal(n);
			while(pn <= p) {
				p2n.put(pn, n);
				n++;
				pn = pentagonal(n);
			}
			maxN = n-1;
		}
	}
}
